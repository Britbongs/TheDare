#include "Player.h"	
#include <iostream>
Player::Player()
	: Entity(sf::Quads, 4), moveSpeed(200), maxSprint(500), sprintTime(maxSprint)
{

	this->setVertexLocalPosition(0, sf::Vector2f(0.f, 0.f));
	this->setVertexLocalPosition(1, sf::Vector2f(1.f, 0.f));
	this->setVertexLocalPosition(2, sf::Vector2f(1.f, 1.f));
	this->setVertexLocalPosition(3, sf::Vector2f(0.f, 1.f));
	/*  

	for (int i(0); i < this->getVertexCount(); ++i)
		this->setVertexColour(i, sf::Color::Green);
		*/
	xCollider.width = 60;		//init colliders size
	xCollider.height = 60;
	yCollider.width = 60;
	yCollider.height = 60;

	sprintRect_.setFillColor(sf::Color::Red); //init sprint rect with colour red
	sprintRect_.setSize(sf::Vector2f(64, 5)); //init sprint rect with width of player and size of 5
	
}

void Player::update(const sf::Time& delta, const float rotation)
{
	updateMovement(delta);
	updateSprintBar();
	updateRotation(rotation);
}

void Player::sprint()
{
	if (sprintTime > 0) //if the sprint timer is greater then 0 then allow sprinting
	{
		moveSpeed = 600;
		--sprintTime; //decrease sprint timer towards 0
	}
	else
	{
		moveSpeed = 200; //sprint timer is equal or less than 0 change move speed to walking pace
	}
	
}

void Player::walk()
{

	moveSpeed = 200; //make sure move speed is walking pace
	if (sprintTime < maxSprint) //if sprint timer is less than the max sprint duration then
	{
		sprintTime += 0.5f; //increase sprint timer back up towards the max duration
	}
}

void Player::updateSprintBar()
{	
	float scaleX = sprintTime / maxSprint; //get percentage of sprint timer
	sprintRect_.setPosition(sf::Vector2f(getGlobalBounds().left, getGlobalBounds().top - 10)); //set the rects position to be just above the player
	sprintRect_.setScale(scaleX, 1); //set the rects size based on sprint timer
}

void Player::updateMovement(const sf::Time& delta)
{
	sf::Vector2f movement;
	sf::Vector2f direction(0, 0);
	sf::Vector2f colMove;
	const float SIZE(1.5f);


	xCollider.top = getPosition().y - xCollider.height / 2.f;
	xCollider.left = getPosition().x - xCollider.width / 2.f;

	yCollider.top = getPosition().y - yCollider.height / 2.f;
	yCollider.left = getPosition().x - yCollider.width / 2.f;

	if (sf::Keyboard::isKeyPressed(sf::Keyboard::LShift))	//press shift and sprint 
	{
		sprint();
	}
	else //otherwise walk
	{
		walk();
	}


	if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) || sf::Keyboard::isKeyPressed(sf::Keyboard::Left) || sf::Keyboard::isKeyPressed(sf::Keyboard::Up) || sf::Keyboard::isKeyPressed(sf::Keyboard::Down)
		|| sf::Keyboard::isKeyPressed(sf::Keyboard::A) || sf::Keyboard::isKeyPressed(sf::Keyboard::D) || sf::Keyboard::isKeyPressed(sf::Keyboard::W) || sf::Keyboard::isKeyPressed(sf::Keyboard::S))
	{ //if a directional key is pressed

		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up) || sf::Keyboard::isKeyPressed(sf::Keyboard::W))
		{//if up key is pressed change direction y vector to -1 and move the y collider above the player
			direction.y = -1;
			yCollider.top -= (moveSpeed * delta.asSeconds());
		}
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down) || sf::Keyboard::isKeyPressed(sf::Keyboard::S))
		{//if down key is pressed change direction y vector to 1 and move the y collider below the player
			direction.y = 1;
			yCollider.top += (moveSpeed * delta.asSeconds());
		}
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left) || sf::Keyboard::isKeyPressed(sf::Keyboard::A))
		{//if left key is pressed change direction x vector to -1 and move the x collider left of the player
			direction.x = -1;
			xCollider.left -= (moveSpeed * delta.asSeconds());
		}
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) || sf::Keyboard::isKeyPressed(sf::Keyboard::D))
		{//if left key is pressed change direction x vector to 1 and move the x collider right of the player
			direction.x = 1;
			xCollider.left += (moveSpeed * delta.asSeconds());
		}

		//create a vector that uses the two colliders and the direction to work out collisions
		colMove = sf::Vector2f(p_tileMap_->collider(xCollider, yCollider, direction));

		if (colMove.y == 0) // if there is no collision move in desired direction
		{
			movement.y = direction.y;
		}

		if (colMove.x == 0)  // if there is no collision move in desired direction
		{
			movement.x = direction.x;
		}


		if (movement.x != 0 && movement.y != 0) //if the movement vector is not (0,0)
		{

			movement = sf::Vector2f(normalize(movement)); //normalize the movement vector so diagnal movement isn't quicker
		}
		movement.x *= moveSpeed * delta.asSeconds();	//times the movement vector by moveSpeed and delta
		movement.y *= moveSpeed * delta.asSeconds();
		move(movement);	//move the player
	}

	//bool moving(movement.x != 0.f || movement.y != 0.f);
}

void Player::updateRotation(const float rotation)
{
	setRotation(rotation);
}
